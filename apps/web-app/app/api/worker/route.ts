import { verifySignatureAppRouter } from "@upstash/qstash/nextjs";
import { NextResponse } from "next/server";
import { prisma } from "@repo/database";
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";

// 使用 GOOGLE_API_KEY 初始化 GoogleGenerativeAI 客户端
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

async function handler(req: Request) {
  let jobId: string | null = null;

  try {
    const body = await req.json();
    jobId = body.jobId;

    if (!jobId) {
      return NextResponse.json({ error: "Missing jobId" }, { status: 400 });
    }

    // 更新状态为 PROCESSING
    await prisma.meetingJob.update({
      where: { id: jobId },
      data: { status: "PROCESSING" },
    });

    const job = await prisma.meetingJob.findUnique({ where: { id: jobId } });
    
    if (!job || !job.fileUrl) {
      throw new Error(`Job not found or fileUrl is missing for job: ${jobId}`);
    }

    // 从 fileUrl 下载文件内容为 Buffer
    const fileResponse = await fetch(job.fileUrl);
    if (!fileResponse.ok) {
      throw new Error(`Failed to download file: ${fileResponse.statusText}`);
    }
    
    const audioBuffer = Buffer.from(await fileResponse.arrayBuffer());
    const audioMimeType = fileResponse.headers.get('content-type') || 'audio/mpeg';

    // 获取模型
    const model = genAI.getGenerativeModel({ 
      model: "gemini-1.5-pro",
      safetySettings: [
        {
          category: HarmCategory.HARM_CATEGORY_HARASSMENT,
          threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
        },
      ],
    });

    // 创建多部分内容，包含音频文件
    const fileContent = {
      inlineData: {
        data: audioBuffer.toString('base64'),
        mimeType: audioMimeType
      }
    };

    // 构造 Prompt
    const promptContent = {
      role: "user",
      parts: [
        { text: `你是一个专业的会议记录分析师。请仔细分析接下来的这段会议音频。分析完成后，请严格按照以下JSON格式返回结果，不要包含任何额外的解释或Markdown标记：{"summary": "这里是会议的核心内容摘要", "actionItems": [{"task": "具体的行动项描述", "assignee": "负责人，如果不明确则为'待定'", "dueDate": "截止日期，如果不明确则为'待定'"}]}` },
        fileContent
      ]
    };

    // 生成内容
    const result = await model.generateContent({
      contents: [promptContent],
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 4000,
      }
    });

    const responseText = result.response.text();

    // 更健壮的 JSON 提取和解析
    let jsonText = responseText;

    // 1. 移除可能的 Markdown 代码块标记
    jsonText = jsonText.replace(/```(?:json)?\n?/g, "").replace(/```/g, "");

    // 2. 查找 JSON 对象的开始和结束位置
    const startIdx = jsonText.indexOf('{');
    const endIdx = jsonText.lastIndexOf('}') + 1;

    if (startIdx >= 0 && endIdx > startIdx) {
      // 提取看起来像 JSON 的部分
      jsonText = jsonText.substring(startIdx, endIdx);
    }

    // 3. 清理可能的多行文本
    jsonText = jsonText.replace(/\n/g, ' ').trim();

    let analysisResult;
    try {
      analysisResult = JSON.parse(jsonText);
      
      // 验证 JSON 结构
      if (!analysisResult.summary || !Array.isArray(analysisResult.actionItems)) {
        throw new Error('Invalid result structure: missing summary or actionItems');
      }
      
    } catch {
      // 如果解析失败，使用正则表达式尝试提取关键信息
      const summaryMatch = responseText.match(/["']summary["']\s*:\s*["']([^"']*)["']/);
      const summary = summaryMatch ? summaryMatch[1] : "无法解析会议摘要";
      
      // 创建一个基本的结构
      analysisResult = {
        summary: summary,
        actionItems: [{
          task: "AI 解析失败，请手动处理会议内容",
          assignee: "待定",
          dueDate: "待定"
        }]
      };
    }

    // 存储结果
    await prisma.analysisResult.create({
      data: {
        jobId: job.id,
        summary: analysisResult.summary,
        actionItems: analysisResult.actionItems,
        transcript: "Generated by Gemini, direct transcript not available.", // Gemini 直接处理音频，不提供独立文本
      },
    });

    // 更新最终状态
    await prisma.meetingJob.update({
      where: { id: job.id },
      data: { status: "COMPLETED" },
    });

    return NextResponse.json({ success: true, jobId });

  } catch {
    if (jobId) {
      await prisma.meetingJob.update({
        where: { id: jobId },
        data: { status: "FAILED" },
      });
    }
    // 即使内部处理失败，也向QStash返回200，避免重试
    return NextResponse.json(
      { error: "Worker processing failed but acknowledged." },
      { status: 200 }
    );
  }
}

// 使用 verifySignatureAppRouter 中间件包装 handler
export const POST = verifySignatureAppRouter(handler);